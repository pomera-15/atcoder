# 計算量
## for文
1 秒間で処理できる for 文ループの回数は、10^8 = 100,000,000 回程度

# python tips
## range
```
range(start, stop[, step])
```
いつも忘れる。

## pythonでのAtcoder的入力の書き方
1行で1単語
```
# N
N = int(input())
```

1行で複数単語(固定の数)
```
# N, K
N, K = map(int, input().split())
```

1行で複数単語(任意の数)
```
# n1 n2 n3 n4 n5
N = list(map(int, input().split())) 
```

複数行で複数単語(個数は事前に指定される)
```
# N
# l1
# l2
# l3
# l4
# l5
L = []
for _ in range(N):
    L.append(int(input()))
```

## アルファベットの辞書
```
alphabet = {
    1: "a", 2: "b", 3: "c", 4: "d", 5: "e", 6: "f", 7: "g", 8: "h", 9: "i", 10: "j", 
    11: "k", 12: "l", 13: "m", 14: "n", 15: "o", 16: "p", 17: "q", 18: "r", 19: "s", 20: "t", 
    21: "u", 22: "v", 23: "w", 24: "x", 25: "y", 26: "z"
    }

alphabet = {
    'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 
    'k': 11, 'l': 12, 'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 
    'u': 21, 'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26
    }
```

## 固定個のバケツを用意する
```
# 1 - 26のバケツを用意する
buckets = {i: None for i in range(1, 26+1)}
```

## W✖️Hの二次元配列を用意する(Trueで埋める)
```
S = []
for x in range(W):
    S.append([])
    for y in range(H):
        S[x].append(True)
```

## 辞書の値が最大のものを求める
```
# valueが最大となるkeyを取得する
res = max(points, key=points.get)

# 最大のvalueを取得する
res = max(points.values())
```

# AGC012A: AtCoder Group Contest
> 3N個の整数から3個ずつのペアを作る。  
> このとき、ペアリングのスコアは各ペアにおける2番目に大きい数の総和とすると、総和はどのようにすれば最大化できるか。  

`12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1`  
で考えると、  
`12, 11, x`  
`10, 9, x`  
`8, 7, x`  
`6, 5, x`  
として、`11+9+7+5=32`が最大となる。  
※ この考え方が思いつかなかった。  

# ABC085B
バケット法  
