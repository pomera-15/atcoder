# 計算量
## for文
1 秒間で処理できる for 文ループの回数は、10^8 = 100,000,000 回程度

# python tips
## range
```
range(start, stop[, step])
```
いつも忘れる。

## pythonでのAtcoder的入力の書き方
1行で1単語
```
# N
N = int(input())
```

1行で複数単語(固定の数)
```
# N, K
N, K = map(int, input().split())
```

1行で複数単語(任意の数)
```
# n1 n2 n3 n4 n5
N = list(map(int, input().split())) 
```

複数行で複数単語(個数は事前に指定される)
```
# N
# l1
# l2
# l3
# l4
# l5
L = []
for _ in range(N):
    L.append(int(input()))
```

## アルファベットの辞書
```
alphabet = {
    1: "a", 2: "b", 3: "c", 4: "d", 5: "e", 6: "f", 7: "g", 8: "h", 9: "i", 10: "j", 
    11: "k", 12: "l", 13: "m", 14: "n", 15: "o", 16: "p", 17: "q", 18: "r", 19: "s", 20: "t", 
    21: "u", 22: "v", 23: "w", 24: "x", 25: "y", 26: "z"
    }

alphabet = {
    'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 
    'k': 11, 'l': 12, 'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 
    'u': 21, 'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26
    }
```

## 固定個のバケツを用意する
```
# 1 - 26のバケツを用意する
buckets = {i: None for i in range(1, 26+1)}
```

## W✖️Hの二次元配列を用意する(Trueで埋める)
```
S = []
for x in range(W):
    S.append([])
    for y in range(H):
        S[x].append(True)
```

## 辞書の値が最大のものを求める
```
# valueが最大となるkeyを取得する
res = max(points, key=points.get)

# 最大のvalueを取得する
res = max(points.values())
```

## filter
```
# 文字が異なるペアだけを filter で抽出し、リストに変換してその長さを求める
diff_count = len(list(filter(lambda pair: pair[0] != pair[1], zip(S, T))))

```

## 無名関数
```
lambda 引数: 返り値
```
以下と同等
```
def func(引数):
    return 返り値
```

# AGC012A: AtCoder Group Contest
> 3N個の整数から3個ずつのペアを作る。  
> このとき、ペアリングのスコアは各ペアにおける2番目に大きい数の総和とすると、総和はどのようにすれば最大化できるか。  

`12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1`  
で考えると、  
`12, 11, x`  
`10, 9, x`  
`8, 7, x`  
`6, 5, x`  
として、`11+9+7+5=32`が最大となる。  
※ この考え方が思いつかなかった。  

# ABC085B
バケット法  

# ABC088C

 - pythonでの A == B == C の書き方  
```
# pythonでは以下のように書ける。  
# if a == b == c:
# if a < b < c:
```

 - 正しいかどうかの判定をする際に、式変形してやりやすい式を評価の対象にする。  
 この問題で言えば、与えられたものが条件を満たすかどうかは以下が正しいかどうかを求めることと同値である。
 ```
c[0][0] - c[1][0] == c[0][1] - c[1][1] == c[0][2] - c[1][2]
c[0][0] - c[2][0] == c[0][1] - c[2][1] == c[0][2] - c[2][2]
c[2][0] - c[0][0] == c[2][1] - c[0][1] == c[2][2] - c[0][2]
c[0][0] - c[0][1] == c[1][0] - c[1][1] == c[2][0] - c[2][1]
c[0][1] - c[0][2] == c[1][1] - c[1][2] == c[2][1] - c[2][2]
c[0][2] - c[0][0] == c[1][2] - c[1][0] == c[2][2] - c[2][0]
```

# ABC395B
二次元配列の問題。  
はじめに空の二次元配列を用意する。  
```
S = []
for x in range(N):
    S.append([])
    for y in range(N):
        S[x].append("*")
```